#!/bin/env/python

import mc3
import numpy as np
import matplotlib.pyplot as plt
from warnings import warn
from inspect import getargspec

# wrappers for interfacing mc3 with jscatter and the rest of the pipeline
# for Bayesian fine-tuning and error estimates

def params_get(fit):
    "Extract dict of fitted params from jscatter dataArray containing mc3 results"
    # get the best estimates
    params = {pname: param for pname, param in zip(fit["pnames"], fit["bestp"])}
    # credible region low-end
    params.update({pname+"_lo": plo for pname, plo in zip(fit["pnames"], fit["CRlo"])})
    # credible region high-end
    params.update({pname+"_hi": phi for pname, phi in zip(fit["pnames"], fit["CRhi"])})
    # don't forget chi2! (under the jscatter name)
    params.update({"chi2": fit["red_chisq"]})
    #NTS consider returning parmeter means and sds as well
    return params
    
def fortranify(ifunc, indpars=['q'], deppars=None):
    """
    Wrap a function with keyword arguments into a leastsq-compatible function that takes
    an (alphabetically!) ordered iterable of parameters.
    """
    # beware, if the function being wrapped uses **kwargs, they will not be captured here!
    if deppars is None: deppars = [par for par in getargspec(ifunc)[0] if par not in indpars]
    def ffunc(p, *indparams):
        "Function wrapped by fortranify()"
        kwargs = {par: p[i] for i, par in enumerate(sorted(deppars))}
        kwargs.update({par: val for par, val in zip(indpars, indparams)})
        #print(kwargs) #TEST
        return ifunc(**kwargs)
    return ffunc
    
def convert_limits(data):
    "Extract the soft limits imposed on a DataArray to pmin, pmax for mc3"
    # alphabetize
    pnames = sorted(data.has_limit.keys())
    pmin = [data.has_limit[p][0] for p in pnames]
    pmax = [data.has_limit[p][1] for p in pnames]
    return ([val if val is not None else -1*np.inf for val in pmin], [val if val is not None else np.inf for val in pmax])
    
def bayes(data, model, mapNames={'q':'X'}, freepar={}, fixpar={}, pstep=None, sampler="snooker", **kwargs):
    """
    Wrapper shoehorns a jscatter DataArray, limits and all, into an mc3
    Bayesian sampling run. **kwargs go to mc3.sample().
    Result gets stored in the data object as data.mcmcfit.
    """
    
    # mc3 handles params rather differently
    params = freepar | fixpar
    # order params alphabetically
    pnames = sorted(params.keys())
    parval = [params[key] for key in pnames]
    
    # wrap the model function
    mod = fortranify(model, indpars=sorted(mapNames.keys()), deppars=pnames)
    
    # now deal with step sizes
    if pstep is None:
        # autogenerate, with appropriate warnings
        pstep = {}
        pstep.update(params)
        # hardcoded 1% steps
        pstep = {key: abs(val/100) for key, val in pstep.items()}
        for key, val in psteps.items():
            if not val:
                warn(
                    """
                    Parameter {} will be fixed due to startval of 0. 
                    If this is not desired, specify step size manually.
                    """.format(key)
                )
    # if pstep is a passed or autogenerated dict, make it a list
    try: pstep = [pstep[key] for key in pnames]
    # else pass it into mc3.sample as-is
    except: pass
    
    # finally, need to apply limits
    pmin, pmax = convert_limits(data)
    
    # change name for convenience
    if "maxfev" in kwargs.keys(): kwargs["nsamples"] = dict.pop("maxfev")
    
    #TEST
    print(kwargs)
    
    # and now (drumroll) start a chain!
    data.mcmcfit = mc3.sample(
        data.Y,
        data.eY,
        mod,
        sampler=sampler,
        params = parval,
        pnames = pnames,
        pstep  = pstep,
        pmin   = pmin,
        pmax   = pmax,
        indparams = [data[mapNames[key]] for key in sorted(mapNames.keys())],
        **kwargs
    )
    return data # is this the right move?
        
def itfit(data, fititers, plot=False, giveup=False, **kwargs):
    """
    Iterative *Bayesian* fitting routine.
    
    data is a jscatter dataArray
    
    fititers has a very specific format:
    
    This is now a generator function that yields the fitted dataArray following
    every fit iter (but not every func evaluation).
    """
    for i, iter in enumerate(fititers):
        # intial run
        if not i:
            bayes(data, mapNames={'q':'X'}, **iter, **kwargs)
        # subsequent iters
        else:
            params_last = params_get(data.mcmcfit)
            # insert those starting values
            iter["freepar"] = {p:params_last[p] for p in iter["freepar"]}
            # fit again
            bayes(data, mapNames={'q':'X'}, **iter, **kwargs)
        yield data